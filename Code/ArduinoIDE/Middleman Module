#include <SPI.h>
#include <RF24.h>
#include <WiFi.h>
#include <HTTPClient.h>

// nRF24 pins
#define CE_PIN  33   
#define CSN_PIN 17   
#define LED_PIN 2    // Built-in LED on most ESP32 boards

// WiFi and Hue settings
const char* WIFI_SSID = "WIFI_SSID";
const char* WIFI_PASS = "WIFI_PASS";
const char* BRIDGE_IP = "BRIDGE_IP";
const char* USERNAME  = "USERNAME";

const int LIGHT1_ID = 1;
const int LIGHT2_ID = 2;

RF24 radio(0, CSN_PIN);  // Manual CE control
uint32_t packets_received = 0;
bool led_state = false;

// Debouncing
unsigned long lastToggleMs = 0;
const unsigned long DEBOUNCE_MS = 500; // 1 second

// Hue helper functions
String apiBase() {
  return String("http://") + BRIDGE_IP + "/api/" + USERNAME;
}

bool huePUT(const String& path, const String& body) {
  HTTPClient http;
  String url = apiBase() + path;
  if (!http.begin(url)) { Serial.println("HTTP begin failed"); return false; }
  http.addHeader("Content-Type", "application/json");
  int code = http.PUT(body);
  String resp = http.getString();
  http.end();
  Serial.printf("PUT %s -> %d | %s\n", url.c_str(), code, resp.c_str());
  return (code >= 200 && code < 300);
}

bool setLightOn(int id, bool on) {
  return huePUT("/lights/" + String(id) + "/state",
                String("{\"on\":") + (on ? "true" : "false") + "}");
}

void toggleBothLights(bool on) {
  setLightOn(LIGHT1_ID, on);
  setLightOn(LIGHT2_ID, on);
}

void ensureWiFi() {
  if (WiFi.status() == WL_CONNECTED) return;
  Serial.printf("Reconnecting to %s", WIFI_SSID);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  int tries = 0;
  while (WiFi.status() != WL_CONNECTED && tries++ < 50) {
    delay(200);
    Serial.print(".");
  }
  Serial.println(WiFi.status() == WL_CONNECTED ? "\nWiFi reconnected." : "\nWiFi reconnect failed.");
}

void setup() {
  Serial.begin(115200);
  while (!Serial) { delay(10); }
  delay(1000);
  
  Serial.println("\n=== nRF24 RX with LED Toggle ===\n");
  
  // Initialize LED
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);
  
  // Connect to WiFi
  Serial.printf("Connecting to %s", WIFI_SSID);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  while (WiFi.status() != WL_CONNECTED) { delay(300); Serial.print("."); }
  Serial.printf("\nWiFi OK. ESP IP: %s\n", WiFi.localIP().toString().c_str());
  
  // Initialize lights to OFF
  toggleBothLights(false);
  
  // Manual CE control
  pinMode(CE_PIN, OUTPUT);
  digitalWrite(CE_PIN, LOW);
  
  // Initialize SPI
  SPI.begin(18, 19, 23, CSN_PIN);
  
  if (!radio.begin()) {
    Serial.println("ERROR: radio.begin() failed!");
    while (1) delay(1000);
  }
  
  // Configure to match your transmitter
  radio.setChannel(76);  
  radio.setPALevel(RF24_PA_LOW);  
  radio.setDataRate(RF24_250KBPS);  
  radio.setPayloadSize(32);  
  
  // Set up as receiver
  radio.openReadingPipe(1, 0x11223344AAULL);  // Same address as TX
  
  // Enable AutoACK 
  radio.setAutoAck(true);
  
  // Start listening
  radio.startListening();
  
  // For RX mode, CE should be HIGH continuously
  digitalWrite(CE_PIN, HIGH);
  
  Serial.println("Configuration:");
  Serial.println("- Channel: 76");
  Serial.println("- Data Rate: 250KBPS");
  Serial.println("- Address: 0x11223344AA");
  Serial.println("- Payload Size: 32 bytes");
  Serial.println("- Mode: RECEIVER");
  Serial.println("- Debounce: 1 second");
  Serial.println("\nListening for transmissions...\n");
  
  // Flash LED to show we're ready
  for(int i = 0; i < 3; i++) {
    digitalWrite(LED_PIN, HIGH);
    delay(100);
    digitalWrite(LED_PIN, LOW);
    delay(100);
  }
  Serial.println("Ready! LED and Hue lights will toggle on each received packet (max once per second).\n");
}

void loop() {
  ensureWiFi();
  
  // Check if data is available
  if (radio.available()) {
    char payload[32];
    radio.read(&payload, 32);
    
    packets_received++;
    
    unsigned long now = millis();
    
    // Check if enough time has passed since last toggle
    if ((now - lastToggleMs) >= DEBOUNCE_MS) {
      // Toggle LED and Hue lights
      led_state = !led_state;
      digitalWrite(LED_PIN, led_state);
      toggleBothLights(led_state);
      lastToggleMs = now;
      
      // Print received data
      Serial.print("[");
      Serial.print(millis()/1000);
      Serial.print("s] RX #");
      Serial.print(packets_received);
      Serial.print(": \"");
      
      // Ensure string is null-terminated for printing
      payload[31] = '\0';
      Serial.print(payload);
      
      Serial.print("\" | LED: ");
      Serial.print(led_state ? "ON" : "OFF");
      Serial.print(" | Lights: ");
      Serial.println(led_state ? "ON" : "OFF");
    } else {
      // Packet received but ignored due to debouncing
      Serial.print("[");
      Serial.print(millis()/1000);
      Serial.print("s] RX #");
      Serial.print(packets_received);
      Serial.print(" - IGNORED (debounce, ");
      Serial.print((DEBOUNCE_MS - (now - lastToggleMs)) / 1000.0, 1);
      Serial.println("s remaining)");
    }
    
    // Clear any remaining packets in case multiple arrived
    while (radio.available()) {
      radio.read(&payload, 32);
      packets_received++;
      Serial.print("  (Additional packet cleared #");
      Serial.print(packets_received);
      Serial.println(")");
    }
  }
  
  // No delay needed - radio.available() is non-blocking
}
